# Introduction #

----------
This is a MCTS (reference: AlphagoZero) program written in python that can be inherited by user-defined child class. Users only need to provide in the child class methods to generate choices for each step s with their probability distribution, and the value function of each step s:
> f(s) = [v, [[s1,s2],[p1,p2]]] 
> 
> or f(s) = [None, [[s1,s2],[p1,p2]]] and V(s) = v.

and provide method to judge weather a state(step/node) is a successful end.

example.py shows an example of how to use this program. Neural networks, computational programs etc. can be linked to the program to generate choices, probability distribution and value.

# Technical Points of Implementation in This Program #

----------
1. API and Inheritance. This program provides an API for MCTS tasks. Users can link their own problems to the MCTS backbone through inheritance of the base class MCTS_BASE, as is described in Introduction and Example part. Policy and value generated through MCTS can be saved for Reinforcement Learning in this program.

2. DFS. This program adopts recursion for DFS search (see mcts_base.py/MCTS_BASE._dfs method). In one recursion, first select choice with max(Q+U) score, then call the function recursively to go to child nodes.

3. Muti-Process Parallel. Note that one choice of a step may generate several child nodes --take Retro-synthesis in Chemistry as an example, one big molecule may be decomposed into 2 simpler molucules through one choice of reaction; and may also be decomposed into 3 simpler molucules through another choice of reaction... Here child nodes of a choice a from a node s is called branches(s,a). DFS across this branches can be paralleled in my design. Since the python interpreter executes threads serially, python must use process parallelism. Here I use the multiprocessing lib in python and conduct parallelism with multiprocessing.Process method. The search space, i.e. the search tree of the nodes and edges already been visited through DFS, is shared across processes using multiprocessing.Manager().dict(). When updating data in a node in the shared search space, process lock multiprocessing.Lock() is adopted to ensure all data from different processes would be collected.

4. Beam search. This program can generate multiple routes. If we want to genetate k routes, for each step, beam search is used to pick the routes with top-k mean probability (from policy generated by MCTS) of all steps. To generate the "second best" route from the best route, only the branch with the highest "second best" probability is substituted, and I use the maximum heap to pick the kth max choice. DFS of each beam in a step is also parallel across processes. Search space of each beam is shared, in order to accumulate results from exploration of the same search space to obtain a more precise probability distribution.

5. Reducing the number of disc readings and avoid double counting of the same object.


# MCTS Algorithm #

----------
MCTS is a tree search method for problems of which the search space cannot be exhausted. MCTS conducts a few times of search to pick the choice with the highest visiting number, i.e. the highest probability to be picked. The backbone of this MCTS references the AlphagoZero paper *Mastering the game of Go without human knowledge*. 

For each step (see mcts_base.py/MCTS_BASE.play method), MCTS conducts several (e.g. 400) times of the exploration and chooses the choice with the max visiting number N and then go to the next step (see MCTS.dfs_main). The MCTS computed probability distribution (policy) of the choices of a step can be seen as a improvement of the prior probability distribution provided by the user (e.g. the neural network guessed probability), and is computed as follows:

> policy(choice a for step/node s) = policy(s,a) = N(s,a)/sum(N(s,a) for all choices a)

After that, MCTS conducts a seach of the search space (a tree or a graph) from the nodes picked and retains those nodes searched. those nodes not searched is considered useless and will be discarded (here I adopt Queue in python to conduct BFS, see MCTS.dfs_main).

The data structure of a node is (see mcts_base.py/NODE class):
> childlist: list of all children
> Nlist: list of visit count for each edge a[i](root, child i)
> Plist: list of prior probability generated by user difined method for each edge
> Qlist: list of average value q(s,a) for each choice a of step s.
> V: value function of the node

For each time of exploration, MCTS does the following things(see MCTS_BASE._dfs):

1. Select. For the current node s, for each edge a(current node, child i):
U(s,a) = cP(s,a)(sum(Nlist)**0.5)/(1+N(s,a)
Choose the edge with the max(Q(s,a)+U(s,a)) and go to its child node.

2. Expand and evaluate. If the node s hasn't been visited, initialize childlist and Plist with the method you've defined. N(s,a) = 0.

3. Backup. 
For each node, for each edge a visited:

N(s,a)++.

V = 1 if s is a successful end node; V = -1 if s has no child for search down; V = value function(s) if search depth reaches max count and s is not an end state.

For avg method, V(s) = mean(V(branch[i] of the choice picked) for branch[i] in a choice) if V(branch[i]) for all i is not -1 else -1.

For min method, V(s) = min(V(branch[i] of the choice picked) for branch[i] in a choice) if V(branch[i]) for all i is not -1 else -1.

Q(s,a) += (V(s)-Q(s,a))/N(s,a)

# An Example for Your Reference #

----------
Here we manually defined a whole search space (see example.json):

![](img/1.png)

Purple value on the edge a from step s means the prior probability of choosing a from s. Note that one edge(choice) may generate multiple child nodes (multiple branches must all be solved). Blue value on the node means the prior value function of the node V(s). Green node means a successful ending, while red node means a step/state which has no choice to go down --a failed ending.

The example of how to use the MCTS_BASE class can be seen in example.py

The result of MCTS with mcts_times = 3, max_route_len = 6, max_search_depth = 2:

For single-route generation (see answers_0_route_0):
![](img/2.png)

For multi-route generation, here we make the program generate 3 alternative routes with beam search:

Top-1 answer (see answers_1_route_0) is the same as that in single-route generation.

Top-2 answer (see answers_1_route_1):
![](img/3.png)

Top-3 answer (see answers_1_route_2): 
![](img/4.png)

As only 2 routes in the whole search space can reach successful ending, the top-3 answer reports a failed result.

As I turned the debug mode on, in log.out you can see data on intermediate processes of MCTS in log.out